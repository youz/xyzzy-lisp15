
;;; M-expression parser (for xyzzy)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (require "ansi-loop"))

(defpackage :lisp1.5.mexpr
  (:use :lisp :lisp1.5)
  (:export #:parse #:parse-buffer))

(in-package :lisp1.5.mexpr)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (shadowing-import '(ansi-loop:loop ansi-loop:loop-finish)))

(defparameter *ripping-table* nil)
(defconstant *separator* (make-symbol "colon"))
(defconstant *bracket* (make-symbol "[]"))
(defconstant *eof* (make-symbol "eof"))
(defconstant *sym-lambda* 'lisp1.5::|lambda|) ; equal 'lisp:lambda in xyzzy
(defconstant *sym-label*  'lisp1.5::|label|)

(defun bracket-reader (s c)
  (let ((*readtable* *ripping-table*))
    `(,*bracket* ,@(read-delimited-list #\] s t))))

(defun bracket-list-p (x)
  (and (consp x) (eq *bracket* (car x))))

(defun init-ripping-table ()
  (setq *ripping-table* (copy-readtable nil))
  (setf (readtable-case *ripping-table*) :preserve)
  (let ((stbl (copy-readtable nil))
	(mtbl *ripping-table*))
    (set-macro-character #\; (lambda (s c) *separator*) nil  mtbl)
    (set-macro-character #\[ #'bracket-reader nil mtbl)
    (set-syntax-from-char #\# #\; mtbl stbl)
    (set-syntax-from-char #\] #\) mtbl stbl)
    mtbl))

(defun read-sym (sym)
  (let* ((s (symbol-name sym))
	 (u (some #'upper-case-p s))
	 (l (some #'lower-case-p s)))
    (when (or (and u l) (notevery #'alphanumericp s))
      (error "invalid word: ~A" sym))
    (if u `(QUOTE ,(intern s))
      (intern (string-upcase s)))))

(defun read-list (x)
  (labels ((rec (e)
	     (cond ((null e) nil)
		   ((consp e) (cons (rec (car e)) (rec (cdr e))))
		   ((numberp e) e)
		   ((symbolp e)
		    (let ((s (read-sym e)))
		      (unless (and (consp s) (eq (car s) 'QUOTE))
			(error "invalid word: ~A" e))
		      (cadr s)))
		   (t (error "invalid word: ~A" e)))))
    `(QUOTE ,(rec x))))

(defun read-lambda-body (bracket-list)
  (let ((form (cdr bracket-list)))
    (unless (and (<=  3 (length form) 4)
		 (bracket-list-p (first form))
		 (eq (second form) *separator*))
      (error "invalid lambda form: lambda ~A" form))
    (let ((param (mapcar #'read-sym (remove *separator* (cdar form)))))
      (multiple-value-bind (e _) (parse-expr (cddr form))
	`(LAMBDA ,param ,e)))))

(defun read-label-body (bracket-list)
  (let ((body (cdr bracket-list)))
    (unless (and (= (length body) 4)
		 (symbolp (first body))
		 (eq *separator* (second body))
		 (eq *sym-lambda* (third body))
		 (bracket-list-p (fourth body)))
      (error "invalid label form: label[~A]" body))
    (let ((name (read-sym (first body)))
	  (f (read-lambda-body (fourth body))))
      `(LABEL ,name ,f))))

(defun read-cond (bracket-list)
  (let ((l (cdr bracket-list))
	(clauses nil))
    (loop while l
      do (multiple-value-bind (test r) (parse-expr l)
	   (let ((arrow (car r)))
	     (unless (find arrow '(-> =>))
	       (error "invalid cond clause: ~S ~S ..." test arrow))
	     (multiple-value-bind (expr r) (parse-expr (cdr r))
	       (case arrow
		 (-> (push (list test expr) clauses))
		 (=> (push (list test '=> expr) clauses)))
	       (unless (or (null r) (eq *separator* (car r)))
		 (error "invalid cond form: [~{~A~^ ~}]" (cdr bracket-list)))
	       (setq l (cdr r))))))
    `(COND ,@(nreverse clauses))))

(defun read-args (bracket-list)
  (let ((l (cdr bracket-list)))
    (loop while l
      collect (multiple-value-bind (e r) (parse-expr l)
		(unless (or (null r) (eq *separator* (car r)))
		  (error "invalid argument from: [~{~A~^ ~}]" (cdr bracket-list)))
		(setq l (cdr r))
		e))))

(defun parse-expr (input)
  (unless input (error "unexpected eof"))
  (let ((x (car input)))
    (cond ((bracket-list-p x) (values (read-cond x) (cdr input)))
	  ((consp x) (values (read-list x) (cdr input)))
	  ((numberp x) (values `(QUOTE ,x) (cdr input)))
	  ((symbolp x)
	   (cond
	    ((eq x *sym-lambda*)
	     (let ((lambdaexpr (read-lambda-body (cadr input)))
		   (rest (cddr input)))
	       (if (bracket-list-p (car rest))
		   (values `(,lambdaexpr ,@(read-args (car rest))) (cdr rest))
		 (values lambdaexpr rest))))
	    ((eq x *sym-label*)
	     (let ((labelexpr (read-label-body (cadr input)))
		   (rest (cddr input)))
	       (if (bracket-list-p (car rest))
		   (values `(,labelexpr ,@(read-args (car rest))) (cdr rest))
		 (values labelexpr rest))))
	    ((bracket-list-p (second input))
	     (values `(,(read-sym x) ,@(read-args (cadr input))) (cddr input)))
	    (t (values (read-sym x) (cdr input)))))
	  (t (error "invalid form: ~A" top)))))

(defun parse-toplevel (input)
  (unless input (error "unexpected eof"))
  (let ((top (car input)))
    (cond ((symbolp top)
	   (cond ((eq (second input) '=)
		  (let ((left (read-sym top)))
		    (multiple-value-bind (v rest) (parse-expr (cddr input))
		      (values `($= ,left ,v) rest))))
		 ((and (bracket-list-p (second input)) (eq (third input) '=))
		  (let* ((param (read-args (second input)))
			 (left (cons (read-sym top) param)))
		    (multiple-value-bind (v rest) (parse-expr (cdddr input))
		      (values `($= ,left ,v) rest))))
		 (t (parse-expr input))))
	   (t (parse-expr input)))))


(defun rip (s)
  (unless *ripping-table*
    (init-ripping-table))
  (let ((*readtable* *ripping-table*))
    (loop for e = (read s nil *eof*)
      while (not (eq e *eof*))
      collect (sublis `((lisp1.5::Å® . ->)
			(lisp1.5::ÅÀ . =>)
			(lisp1.5::É… . ,*sym-lambda*))
		      e))))

(defun parse (str)
  (let ((*package* (find-package :lisp1.5))
	(s (if (streamp str) str (make-string-input-stream str)))
	(acc (list '$TOPLEVELS)))
    (loop
      for input = (rip s)
      then (multiple-value-bind (e r) (parse-toplevel input)
	     (push e acc)
	     r)
      while input)
    (nreverse acc)))

(defun parse-buffer (buf)
  (ed:with-input-from-buffer (buf)
    (parse *standard-input*)))

(provide "lisp1.5/mexpr")
